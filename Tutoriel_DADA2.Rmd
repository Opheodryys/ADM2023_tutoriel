---
title: "R Notebook"
output: github_document
---
```{bash}
git config --global user.email "you@example.com"
git config --global user.name "Your Name"
```

1.

```{bash, eval=FALSE}
wget https://github.com/ANF-MetaBioDiv/course-material/archive/refs/heads/main.zip
unzip main.zip
```

On commence par créer une variable refdb_folder qui crée un fichier. On demande à R de créer un fichier portant ce nom si jamais il n'existe pas. L'argument recursive = TRUE signifie qu'on autorise ce fichier à créer des sous-dossiers

```{r}
refdb_folder <- here::here("data", "refdb")
refdb_folder
if (!dir.exists(refdb_folder)) dir.create(refdb_folder, recursive = TRUE)
```

On dit à R de copier les séquences dans le bon dossier.

```{bash}
cp -R course-material-main/data/raw ./data
```

On dit à R d'augmenter le temps avant qu'il arrête tout seul le téléchargement (on lui donne 20 minutes).

```{r}
getOption("timeout")
options(timeout=1200)
```

Cette variable reçoit le chemin dans le fichier refdb.

```{r}
silva_train_set <- file.path(refdb_folder, "silva_nr99_v138.1_train_set.fa.gz")

```

```{r}
silva_species_assignment <- file.path(refdb_folder,"silva_species_assignment_v138.1.fa.gz")
```

On télécharge ensuite les données sur Zenodo si le fichier de données n'existe pas dans le fichier. Pour la première, on télécharge ce fichier de données dans le bon fichier créé. L'argument quiet = TRUE permet de faire un DL sans afficher la progression du téléchargement. Pareil pour la deuxième.

```{r}
if (!file.exists(silva_train_set)) {
  download.file(
    "https://zenodo.org/record/4587955/files/silva_nr99_v138.1_train_set.fa.gz",
    silva_train_set,
    quiet = TRUE
  )
}


if (!file.exists(silva_species_assignment)) {
  download.file(
    "https://zenodo.org/record/4587955/files/silva_species_assignment_v138.1.fa.gz",
    silva_species_assignment,
    quiet = TRUE
  )
}


```

2.

On fait une nouvelle variable qui donnera le chemin. On crée 2
nouvelles variables qui vont chacune regrouper les séquences possédant R1 dans l'une et R2 dans l'autre.
 
```{r}
path_to_fastqs <- here::here("data", "raw")

fnFs <- sort(list.files(path_to_fastqs, pattern = "_R1.fastq.gz", full.names = TRUE))

fnRs <- sort(list.files(path_to_fastqs, pattern = "_R2.fastq.gz",full.names = TRUE))
```

basename retire le chemin pour y accéder pour garder uniquement le nom du fichier. |> permet de faire des chaînes de fonctions sans utiliser de commandes ou de parenthèses. La traduction est tuyau, donc la commande rentre dans le tuyau. strsplit() coupe la chaîne selon le pattern indiqué entre " ". sapply() applique une fonction à chaque élément de la liste ou du vecteur pour le simplifier, ici on sélectionne juste le premier élément de la liste (juste le nom des échantillons).

```{r}
sample_names <- basename(fnFs) |>
  strsplit(split = "_") |>
  sapply(head, 1)
```

D'abord, on liste les noms des fichiers R1.

```{r}
basename(fnFs) |>
  head()
```

La fonction strsplit() permet de séparer chaque nom de fichier en un vecteur comportant 2 élémentss. Le résultat est une lis de vecteurs avec 2 éléments.

```{r}
basename(fnFs) |>
  strsplit(split = "_") |>
  head()
```

Maintenant, on retient uniquement la première partie du nom, soit SxX.

```{r}
basename(fnFs) |>
  strsplit(split = "_") |>
  sapply(head, 1) |>
  head()
```

On indique à R l'endroit où se trouvent les outils.

```{r, eval=FALSE}
devtools::load_all(path="/home/rstudio/ADM2023_tutoriel/course-material-main/R")
```

3.

On crée une variable quality_folder avec le chemin menant aux graphiques. Ainsi, si le fichier n'existe pas, one le fait dans notre répertoire. Par exemple : fichier 1 : la séquence va de 1 à 300 pb. 2000 séquences du S11B sont lues. La ligne rouge est le nombre de read qui ont au moins cette longueur (ici 100% car Illumina fait obligatoirement la même longueur). Score que qualité diminue chez les R1 à la fin. On veut se débarrasser de tout ce qui est moins bien (garder tout en dessous de Q30). A partir de 200nt, on passe en dessous. Il faut toujours garder 20-30 nt de chevauchement pour les aligner.

```{r}
quality_folder <- here::here("outputs",
                             "dada2",
                             "quality_plots")

if (!dir.exists(quality_folder)) {
  dir.create(quality_folder, recursive = TRUE)
}

qualityprofile(fnFs,
               fnRs,
               file.path(quality_folder, "quality_plots.pdf"))
```

4.

On souhaite raccourcir les séquences pour retirer les bases avec le moins bon Qscore. On crée une variable pour diriger R vers les séquences raccourcies. Pareil, si la direction n'existe pas, on crée une direction vers ce fichier.

```{r}
path_to_trimmed_reads <- here::here(
  "outputs",
  "dada2",
  "trimmed"
)

if (!dir.exists(path_to_trimmed_reads)) dir.create(path_to_trimmed_reads, recursive = TRUE)
```

On attribue à l'amorce directe et reverse leur séquence respective. 

```{r}
primer_fwd  <- "CCTACGGGNBGCASCAG"
primer_rev  <- "GACTACNVGGGTATCTAAT"
```

On lit les 10 premières et 10 dernières séquences R1 et R2

```{r}
Biostrings::readDNAStringSet(
  fnFs[1],
  format = "fastq",
  nrec = 10
)
```
```{r}
Biostrings::readDNAStringSet(
  fnRs[1],
  format = "fastq",
  nrec = 10
)
```

On copie les informations du dossier bash dans un nouveau dossier bash dans le ADM2023_tutoriel.

```{bash}
pwd
cp -R /home/rstudio/ADM2023_tutoriel/course-material-main/bash .
```

La variable primer_log prend la fonction primer_trim comme objet. forward et reverse correspondent aux séquences directes et complémentaires. primer_fwd et primer_rev correspondent aux amorces. output_dir permet de noter toutes les séquences raccourcies. Les séquences raccourcies doivent faire plus de 200 pb.

```{r}
(primer_log <- primer_trim(
  forward_files = fnFs,
  reverse_files = fnRs,
  primer_fwd = primer_fwd,
  primer_rev = primer_rev,
  output_dir = path_to_trimmed_reads,
  min_size = 200
))
```

On extrait les séquences raccourcies pour les séquences directes et complémentaires en demandant tous les noms.

```{r}
nopFw <- sort(list.files(path_to_trimmed_reads, pattern ="R1", full.names = TRUE))
nopRv <- sort(list.files(path_to_trimmed_reads, pattern ="R2", full.names = TRUE))
```

5.

On crée un dossier menant aux séquences filtrées. 

```{r}
path_to_filtered_reads <- here::here("outputs", "dada2", "filtered")
if (!dir.exists(path_to_filtered_reads)) dir.create(path_to_filtered_reads, recursive = TRUE)
```

```{r}
filtFs <- file.path(path_to_filtered_reads, basename(fnFs))
filtRs <- file.path(path_to_filtered_reads, basename(fnRs))
```

```{r}
names(filtFs) <- sample_names
names(filtRs) <- sample_names
```

Il faut que chaque R1 ait une séquence R2 associée, sinon elle sera retirée. Il ne faut pas d'ambiguités (argument maxN). Dès qu'on a  --> aide sur le site.

```{r}
(out <- dada2::filterAndTrim(
  fwd = nopFw,
  filt = filtFs,
  rev = nopRv,
  filt.rev = filtRs,
  minLen = 150,
  matchIDs = TRUE,
  maxN = 0,
  maxEE = c(3, 3),
  truncQ = 2
))
```

6.

On attribue à un nouvel objet errF et errR la fonction de résolution d'erreurs de dada2, avec comme argument les séquences filtrées tirées aléatoirement parmi toutes les séquences filtrées totales. On applique ensuite la fonction dada2::plotErrors pour faire un graphique des erreurs observées de chaque transition.

```{r}
errF <- dada2::learnErrors(filtFs,
                           randomize = TRUE,
                           multithread = TRUE)

errR <- dada2::learnErrors(filtRs,
                           randomize = TRUE,
                           multithread = TRUE)
dada2::plotErrors(errF, nominalQ=TRUE)
```

On retire ensuite les séquences lues en double. Pour chaque séquence unique, on compte le nombre de lectures.

```{r}
derepFs <- dada2::derepFastq(filtFs, verbose = TRUE)
derepRs <- dada2::derepFastq(filtRs, verbose = TRUE)
```

Dada2 retire les erreurs et faire correspondre les séquences entre elles. 

```{r}
dadaFs <- dada2::dada(derepFs, err = errF, multithread = TRUE)
dadaRs <- dada2::dada(derepRs, err = errR, multithread = TRUE)
```

7.


```{r}
mergers <- dada2::mergePairs(
  dadaF = dadaFs,
  derepF = derepFs,
  dadaR = dadaRs,
  derepR = derepRs,
  maxMismatch = 0,
  verbose = TRUE
)
```

8.


```{r}
seqtab <- dada2::makeSequenceTable(mergers)
```

